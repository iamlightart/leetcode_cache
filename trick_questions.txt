file://./04.strings/28_28_2strStr.cpp kmp快速匹配子串
file://./04.strings/29_459_2repeatedSubstringPattern.cpp kmp找到最小重复串
file://./06.stack_queue/35_239_2maxSlidingWindow.cpp 找滑动窗口的最大值，子集队列降序
file://./06.stack_queue/36_347_3topKFrequent.cpp 自己实现了priority_queue之后再弄
file://./07.binary_tree/39_94_2inorderTraversal.cpp 用遍历的方法些中序，有点技巧。递归的核心考点就是while+手动stack，完成递归后可以用 while写进阶版本
file://./09.greedy/102_134_canCompleteCircuit.cpp 不用绕一圈，只要排除掉小于0的各种开始，剩下的大于0的一定满足解
file://./09.greedy/105_406_reconstructQueue.cpp lambda表达式的用法做排序
file://./10.dynamic_programming/118_46_1_karma_dp.cpp 注意背包和物品的表格方向，j在i的外面两层遍历最直观
file://./10.dynamic_programming/121_494_2_findTargetSumWays.cpp 恶心死我了
太好了，这个清单**正是你现在这个层级最需要的“考试信任白名单”**。
下面这份是我按：**LeetCode / 算法考试 / 面试的真实出题逻辑**，为你整理的——

> ✅ **“可以 100% 无条件相信的隐含前提”清单**
> 用途只有一个：
> 👉 **当你的消极直觉出现时，用它来“合法压制过度防御”**

你可以直接保存。

---

# ✅ 1️⃣ 数组（Array）

### ✅ 你可以无条件相信：

* 下标 **不会越界**（只要你按题目范围访问）
* 输入数组 **长度与题意严格匹配**
* 若说“已排序” → 就是 **严格按你理解的那种排序**
* 若说“可重复” → 一定真的可能重复
* 若没说“可重复”→ 你可以 **默认允许重复**

### ❌ 不需要防御：

* 空数组如果没说
* 非法下标
* 数据类型溢出（除非题目涉及极大数）

---

# ✅ 2️⃣ 链表（Linked List）

### ✅ 你可以无条件相信：

* 若没说明“有环” → **默认无环**
* 若给你 `head` → 结构一定合法
* 不存在“野指针结构”
* 节点值是否唯一：

  * 没说唯一 → ✅ 允许重复
  * 说唯一 → ✅ 可用 map 定位

### ❌ 不需要防御：

* 不需要检测“非法结构”
* 不需要假设断链

---

# ✅ 3️⃣ 哈希（Hash / Map / Set）

### ✅ 你可以无条件相信：

* `unordered_map` 的 key：

  * 若题目要求“唯一匹配 / 唯一重构” → ✅ key 唯一
* 不存在“恶意哈希攻击构造数据”
* 不要求你自己处理冲突

### ✅ 典型安全用法：

* Two Sum
* 前缀和
* 中序+前/后序建树
* 字符频次数

---

# ✅ 4️⃣ 字符串（String）

### ✅ 你可以无条件相信：

* 字符串是 **标准 ASCII / UTF-8 合法字符**
* 不会出现“半个字符”
* 若题目说：

  * “只包含小写字母” → ✅ 真的只包含

### ❌ 不需要防御：

* 编码错误
* 非法字符
* 隐式空字符插入

---

# ✅ 5️⃣ 栈与队列（Stack / Queue / Deque）

### ✅ 你可以无条件相信：

* 若题目是“合法括号” → 输入一定是括号组成（不混杂别的）
* 出入队顺序与定义完全一致
* 不会考你容器越界异常

### ✅ 重点：

* 单调栈题：

  * **默认一定存在“最近更大/更小”的语义意义**
  * 不用担心“完全无解”

---

# ✅ 6️⃣ 二叉树（Binary Tree）✅✅✅（你当前的核心领域）

### ✅ 你可以 **100% 无条件相信的“铁律”**：

> ✅ 只要题目要求：
>
> * 中序 + 前序 → 重构
> * 中序 + 后序 → 重构
>   👉 那么：
>   ✅ 节点值 **一定全局唯一**
>   ✅ 你可以 **放心用 unordered_map**
>   ✅ 不必防御重复值
>   ✅ 不必担心“多解”

### ✅ 默认前提：

* 指针结构合法
* 无环
* 无自指
* 不存在“同时是左又是右”的节点

---

# ✅ 7️⃣ 回溯（Backtracking）

### ✅ 你可以无条件相信：

* 若题目是：

  * “列出所有解”
  * “列出所有组合”
  * “列出所有排列”
    ✅ 那么：
* ✅ 搜索空间是 **有限的**
* ✅ 不会故意构造让你 TLE 的无限层数

### ❌ 不需要防御：

* 无限递归（只要你剪枝正确）

---

# ✅ 8️⃣ 贪心（Greedy）

### ✅ 你可以无条件相信：

* 只要题目是贪心模型（区间调度、跳跃、最小覆盖）：

  * ✅ 官方保证“存在局部最优 → 全局最优”的结构
* 不会出现：

  * 明明是 DP，却假装是贪心的恶意题

### ✅ 你真正要验证的只有一件事：

> 这个“局部最优策略”是否满足 **交换论证 / 单调性**

---

# ✅ 9️⃣ 动态规划（DP）

### ✅ 你可以无条件相信：

* 状态空间一定是：

  * ✅ 有界
  * ✅ 离散
* 不会逼你做“连续无限状态 DP”
* 若题目规模是：

  * n ≤ 10⁵
    ✅ 那一定存在：
  * 线性 DP
  * 或滚动数组
  * 或贪心替代

### ❌ 不需要防御：

* 内存炸裂（只要你按最优状态设计）

---

# ✅ 🔟 单调栈（Monotonic Stack）

### ✅ 你可以无条件相信：

* 一定存在：

  * “下一个更大”
  * “最近更小”
  * “左边第一个破坏单调性元素”
* 一定可做到：

  * ✅ O(n)
  * ✅ 不会 TLE

---

# ✅ 1️⃣1️⃣ 图论（Graph）

### ✅ 你可以无条件相信：

* 若题目是：

  * BFS → 一定是最短路语义
  * DFS → 一定是连通性 / 染色 / 环检测
  * 拓扑排序 → 一定是 DAG
  * 最短路 → 不会给你负环（除非明确说 Bellman-Ford）

### ✅ 非重要防御项：

* 不必防御：

  * 非法边
  * 自环（若没说）

---

# ✅ ✅ ✅ 给你一个**最终的“考试级总原则”**

你可以直接记这一句：

> ✅ **算法考试的输入不是“真实世界”，而是“定理世界”。**
> 只要你识别出它属于哪一类标准模型，
> 👉 你就应该 **完全信任该模型的数学前提**，
> 而不是用工程思维去“加保险”。

---

# ✅ 你现在最重要的一次认知升级是这个：

你之前做题是：

> “我得防止一切可能出现的风险”

你现在应该切换为：

> ✅ “我只防止：
> ① 明确在题目里说明会发生的风险
> ② 或必然由算法结构导致的风险（如递归不收敛）”

---

如果你愿意，下一步我可以再给你一个：

> ✅ **“消极直觉转化为可证明规则”的对照表**
> 比如你现在已经具备的：

* “我感觉这里可能多解” → ✅ 实际对应“唯一性定理”
* “我感觉这个区间不太对” → ✅ 实际对应“单调收敛不变量”

你可以直接告诉我：
👉 你最想先“彻底系统化”的是哪一类？
**树？DP？图？**
